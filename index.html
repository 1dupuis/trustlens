<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>trustlens</title>
  <!-- Font Awesome & Animate.css for icons/animations -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
  <style>
/* IMPORT FONT */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

/* ========================================================================== 
   ROOT VARIABLES & GLOBAL SETTINGS
   ========================================================================== */
:root {
  --primary: #fe2c55;
  --primary-hover: #ff4d70;
  --secondary: #25f4ee;
  --background: #121212;
  --surface: #1e1e1e;
  --text: #ffffff;
  --text-secondary: #a8a8a8;
  --trust-high: #22c55e;
  --trust-medium: #f59e0b;
  --trust-low: #ef4444;
  --glass-bg: rgba(255, 255, 255, 0.1);
  --glass-border: rgba(255, 255, 255, 0.05);
  --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
            0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --font-base: 'Inter', sans-serif;
  --border-radius: 8px;
  --modal-radius: 20px 20px 0 0;
  --padding: 1rem;
}

/* ========================================================================== 
   GLOBAL RESET & BASE STYLES
   ========================================================================== */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: var(--font-base);
  background: var(--background);
  color: var(--text);
  line-height: 1.5;
  overflow: hidden;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
}

/* ========================================================================== 
   MAIN CONTAINER & SCROLL SETTINGS
   ========================================================================== */
.app-container {
  width: 100%;
  height: 100vh;
  overflow-y: scroll;
  scroll-snap-type: y mandatory;
  scroll-behavior: smooth;
  position: relative;
  scrollbar-width: none;
}
.app-container::-webkit-scrollbar {
  display: none;
}

/* ========================================================================== 
   VIDEO FEED & CONTAINERS
   ========================================================================== */
#videos {
  display: flex;
  flex-direction: column;
}
.video-container {
  position: relative;
  height: 100vh;
  scroll-snap-align: start;
  background: var(--surface);
  overflow: hidden;
  will-change: transform;
}
.video-container iframe {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* ========================================================================== 
   VIDEO INFO OVERLAY & LAYOUT REVAMP
   --------------------------------------------------------------------------
   We now use a flex layout for the overlay so that the left content
   (user info, video stats) sits beside the AI analysis panel.
   ========================================================================== */
.video-info {
  position: absolute;
  bottom: 80px; /* Raised above the fixed nav bar */
  left: 0;
  right: 0;
  padding: 1.5rem;
  background: linear-gradient(transparent, rgba(0, 0, 0, 0.95));
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  
  display: flex;
  flex-wrap: wrap;
  align-items: flex-start;
  justify-content: space-between;
}

/* Grouping the left info items (user & stats) */
.info-left {
  flex: 1 1 55%;
  min-width: 250px;
}

/* User Info & Video Stats */
.user-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.5rem;
}
.user-avatar {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: var(--glass-bg);
  border: 2px solid var(--primary);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow);
}
.username {
  font-weight: 600;
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}
.caption {
  font-size: 1rem;
  margin-bottom: 0.5rem;
  line-height: 1.6;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}
.video-stats {
  font-size: 0.9rem;
  color: var(--text-secondary);
  margin-bottom: 1rem;
  display: flex;
  gap: 1rem;
}

/* AI Analysis Panel (right column) */
.ai-analysis {
  flex: 1 1 40%;
  min-width: 200px;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: 16px;
  padding: 1rem;
  box-shadow: var(--shadow);
  animation: fadeIn 0.3s ease;
  /* Ensure the panel is pushed to the right */
  margin-left: auto;
}
.trust-score {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
  font-weight: 500;
}
.trust-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  position: relative;
  box-shadow: 0 0 10px currentColor;
}
.trust-indicator::after {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border-radius: 50%;
  background: inherit;
  opacity: 0.3;
  animation: pulse 2s infinite;
}
.high-trust {
  background: var(--trust-high);
  color: var(--trust-high);
}
.medium-trust {
  background: var(--trust-medium);
  color: var(--trust-medium);
}
.low-trust {
  background: var(--trust-low);
  color: var(--trust-low);
}
.ai-explanation {
  font-size: 0.95rem;
  color: var(--text-secondary);
  line-height: 1.6;
  letter-spacing: 0.01em;
}

/* ========================================================================== 
   SIDE ACTION BUTTONS (LIKE, COMMENT, FACT-CHECK)
   ========================================================================== */
.side-actions {
  position: absolute;
  right: 1rem;
  bottom: 11.25rem; /* approx. 180px */
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  z-index: 10;
  padding: 0.25rem;
}
.action-button {
  background: none;
  border: none;
  color: var(--text);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.375rem;
  cursor: pointer;
  transition: var(--transition);
  padding: 0.25rem;
}
.action-button:hover {
  transform: scale(1.1);
}
.action-button:active {
  transform: scale(0.95);
}
.action-icon {
  width: 56px;
  height: 56px;
  background: var(--glass-bg);
  border: 2px solid var(--glass-border);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.4rem;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  transition: var(--transition);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
.like-btn.liked .action-icon {
  background: var(--primary);
  border-color: var(--primary-hover);
  color: var(--trust-high);
  box-shadow: 0 0 15px var(--primary);
}
.action-button:hover .action-icon {
  background: var(--primary);
  border-color: var(--primary-hover);
  transform: translateY(-2px);
}
.action-count {
  font-size: 0.85rem;
  font-weight: 500;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

/* ========================================================================== 
   NAVIGATION BAR
   ========================================================================== */
.navigation {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 60px;
  background: var(--surface);
  display: flex;
  justify-content: space-around;
  align-items: center;
  z-index: 100;
  border-top: 1px solid var(--glass-border);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 -1px 10px rgba(0, 0, 0, 0.2);
}
.nav-item {
  color: var(--text-secondary);
  text-decoration: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.75rem;
  font-weight: 500;
  transition: var(--transition);
  padding: 0.5rem 1rem;
  border-radius: var(--border-radius);
}
.nav-item:hover {
  color: var(--text);
  transform: translateY(-2px);
  background: var(--glass-bg);
}
.nav-icon {
  font-size: 1.2rem;
}
.nav-item.active {
  color: var(--primary);
  position: relative;
}
.nav-item.active::after {
  content: '';
  position: absolute;
  bottom: -0.5rem;
  left: 50%;
  transform: translateX(-50%);
  width: 0.25rem;
  height: 0.25rem;
  background: var(--primary);
  border-radius: 50%;
}

/* ========================================================================== 
   MODAL SECTIONS: COMMENTS, LIKED VIDEOS & SEARCH
   --------------------------------------------------------------------------
   Extra bottom padding is added so that content isn’t hidden behind the nav bar.
   ========================================================================== */
.comments-section,
.liked-videos-section,
.search-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--surface);
  border-radius: var(--modal-radius);
  padding: 1.5rem 1.5rem 80px; /* extra bottom padding */
  transition: var(--transition);
  z-index: 1000;
  overflow-y: auto;
  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
}
.comments-section,
.liked-videos-section {
  height: 70%;
  transform: translateY(100%);
}
.comments-section.show,
.liked-videos-section.show {
  transform: translateY(0);
}
.search-section {
  height: 100%;
  background: var(--background);
  transform: translateY(-100%);
}
.search-section.show {
  transform: translateY(0);
}
.comments-header,
.liked-videos-header,
.search-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid var(--glass-border);
}
.comments-title,
.liked-videos-title,
.search-title {
  font-weight: 600;
  font-size: 1.1rem;
}
.close-comments,
.close-liked-videos,
.close-search {
  background: none;
  border: none;
  color: var(--text);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 50%;
  transition: var(--transition);
}
.close-comments:hover,
.close-liked-videos:hover,
.close-search:hover {
  background: var(--glass-bg);
  transform: rotate(90deg);
}

/* ========================================================================== 
   COMMENTS LIST & COMMENT ITEMS
   ========================================================================== */
#commentsList {
  max-height: 60%;
  overflow-y: auto;
  margin-bottom: 1rem;
  padding-right: 0.5rem;
}
.comment {
  display: flex;
  gap: 1rem;
  margin-bottom: 1.5rem;
  padding: 0.5rem;
  border-radius: 12px;
  animation: slideInUp 0.3s ease;
  transition: var(--transition);
}
.comment:hover {
  background: var(--glass-bg);
}
.comment-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--glass-bg);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  border: 1px solid var(--glass-border);
}
.comment-content {
  flex: 1;
}
.comment-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.25rem;
}
.comment-username {
  font-weight: 600;
  font-size: 0.9rem;
}
.comment-time {
  font-size: 0.8rem;
  color: var(--text-secondary);
}
.comment-text {
  line-height: 1.4;
  margin-bottom: 0.5rem;
}
.new-comment {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem;
  background: var(--glass-bg);
  border-radius: 12px;
  border: 1px solid var(--glass-border);
}
.new-comment input {
  flex: 1;
  padding: 0.75rem;
  border-radius: var(--border-radius);
  border: 1px solid var(--glass-border);
  background: var(--surface);
  color: var(--text);
  font-size: 0.9rem;
  transition: var(--transition);
}
.new-comment input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 2px var(--primary-hover);
}
.new-comment button {
  padding: 0.75rem 1.5rem;
  border: none;
  background: var(--primary);
  color: #fff;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: var(--transition);
  font-weight: 500;
}
.new-comment button:hover {
  background: var(--primary-hover);
  transform: translateY(-2px);
}
.new-comment button:active {
  transform: translateY(0);
}

/* ========================================================================== 
   LIKED VIDEOS SECTION
   ========================================================================== */
#likedVideosList .liked-video {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.75rem;
  margin-bottom: 1rem;
  border-radius: 12px;
  cursor: pointer;
  transition: var(--transition);
}
#likedVideosList .liked-video:hover {
  background: var(--glass-bg);
  transform: translateX(8px);
}
.liked-video-thumbnail {
  width: 120px;
  height: 68px;
  border-radius: var(--border-radius);
  object-fit: cover;
}
.liked-video-info {
  flex: 1;
}
.liked-video-title {
  font-weight: 600;
  margin-bottom: 0.25rem;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.liked-video-channel {
  font-size: 0.85rem;
  color: var(--text-secondary);
}

/* ========================================================================== 
   SEARCH SECTION
   ========================================================================== */
.search-input-container {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 1rem;
  padding: 0.75rem;
  background: var(--glass-bg);
  border-radius: 12px;
  border: 1px solid var(--glass-border);
}
.search-input-container input {
  flex: 1;
  padding: 0.75rem 1rem;
  border-radius: var(--border-radius);
  border: 1px solid var(--glass-border);
  background: var(--surface);
  color: var(--text);
  font-size: 0.95rem;
  transition: var(--transition);
}
.search-input-container input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 2px var(--primary-hover);
}
.search-input-container button {
  padding: 0.75rem 1.5rem;
  border: none;
  background: var(--primary);
  color: #fff;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: var(--transition);
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.search-input-container button:hover {
  background: var(--primary-hover);
  transform: translateY(-2px);
}
.search-input-container button:active {
  transform: translateY(0);
}
#searchResults {
  overflow-y: auto;
  padding: 0 0.75rem;
}
.search-result {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.75rem;
  margin-bottom: 1rem;
  border-radius: 12px;
  cursor: pointer;
  transition: var(--transition);
  border: 1px solid transparent;
}
.search-result:hover {
  background: var(--glass-bg);
  border-color: var(--glass-border);
  transform: translateX(8px);
}
.search-result-thumbnail {
  width: 160px;
  height: 90px;
  border-radius: var(--border-radius);
  object-fit: cover;
}
.search-result-info {
  flex: 1;
  color: var(--text);
}
.search-result-title {
  font-weight: 600;
  margin-bottom: 0.5rem;
  font-size: 1rem;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.search-result-channel {
  font-size: 0.85rem;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* ========================================================================== 
   ANIMATIONS
   ========================================================================== */
@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 0.3;
  }
  50% {
    transform: scale(1.5);
    opacity: 0.1;
  }
  100% {
    transform: scale(1);
    opacity: 0.3;
  }
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
.loader {
  width: 24px;
  height: 24px;
  border: 3px solid var(--text);
  border-bottom-color: transparent;
  border-radius: 50%;
  display: inline-block;
  animation: rotation 1s linear infinite;
}
@keyframes rotation {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* ========================================================================== 
   CUSTOM SCROLLBAR (WEBKIT)
   ========================================================================== */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: var(--surface);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb {
  background: var(--glass-bg);
  border-radius: 4px;
  border: 2px solid var(--surface);
}
::-webkit-scrollbar-thumb:hover {
  background: var(--glass-border);
}

/* ========================================================================== 
   RESPONSIVE DESIGN & DEVICE FIT
   ========================================================================== */

/* For small devices, stack the video info vertically */
@media (max-width: 600px) {
  .video-info {
    flex-direction: column;
    align-items: flex-start;
    padding: 1rem;
  }
  .ai-analysis {
    width: 100%;
    margin: 1rem 0 0 0;
  }
  .info-left {
    width: 100%;
  }
}

/* Tablet adjustments */
@media (min-width: 601px) and (max-width: 1024px) {
  .video-info {
    padding: 1.25rem;
  }
  .ai-analysis {
    flex: 1 1 40%;
  }
  .side-actions {
    right: 0.75rem;
    bottom: 10rem;
  }
  .action-icon {
    width: 52px;
    height: 52px;
    font-size: 1.3rem;
  }
}

/* Laptops and larger screens */
@media (min-width: 1025px) {
  .video-info {
    padding: 1.5rem;
  }
  .ai-analysis {
    flex: 1 1 40%;
  }
}
</style>

</head>
<body>
  <!-- Main app container -->
  <div class="app-container">
    <div id="videos"></div>
    <div id="sentinel"></div>
  </div>

  <!-- Comments Section -->
  <div class="comments-section" id="commentsSection">
    <div class="comments-header">
      <div class="comments-title">Comments</div>
      <button class="close-comments" id="closeComments"><i class="fas fa-times"></i></button>
    </div>
    <div id="commentsList">
      <!-- Comments will be inserted here -->
    </div>
    <div class="new-comment">
      <input type="text" id="commentInput" placeholder="Add a comment..." />
      <button id="submitComment">Post</button>
    </div>
  </div>

  <!-- Liked Videos Section -->
  <div class="liked-videos-section" id="likedVideosSection">
    <div class="liked-videos-header">
      <div class="liked-videos-title">Liked Videos</div>
      <button class="close-liked-videos" id="closeLikedVideos"><i class="fas fa-times"></i></button>
    </div>
    <div id="likedVideosList">
      <!-- Liked videos will be loaded here -->
    </div>
  </div>

  <!-- Search Section -->
  <div class="search-section" id="searchSection">
    <div class="search-header">
      <div class="search-title">Search Videos</div>
      <button class="close-search" id="closeSearch"><i class="fas fa-times"></i></button>
    </div>
    <div class="search-input-container">
      <input type="text" id="searchInput" placeholder="Enter search query..." />
      <button id="executeSearch">Search</button>
    </div>
    <div id="searchResults">
      <!-- Search results will be displayed here -->
    </div>
  </div>

  <!-- Navigation Bar -->
  <div class="navigation">
    <a href="#" class="nav-item active" id="navHome">
      <i class="fas fa-home nav-icon"></i>
      <span>Home</span>
    </a>
    <a href="#" class="nav-item" id="navSearch">
      <i class="fas fa-search nav-icon"></i>
      <span>Search</span>
    </a>
    <a href="#" class="nav-item" id="navLiked">
      <i class="fas fa-heart nav-icon"></i>
      <span>Liked</span>
    </a>
  </div>

  <!-- Load the YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    /*****************************************
     * COOKIE HELPER FUNCTIONS (with encoding)
     *****************************************/
    function setCookie(name, value, days) {
      let expires = "";
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + expires + "; path=/";
    }

    function getCookie(name) {
      const nameEQ = encodeURIComponent(name) + "=";
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i].trim();
        if (c.indexOf(nameEQ) === 0) {
          return decodeURIComponent(c.substring(nameEQ.length));
        }
      }
      return null;
    }

    function eraseCookie(name) {   
      document.cookie = encodeURIComponent(name) + '=; Max-Age=-99999999; path=/';
    }

    /*****************************************
     * LOCAL STORAGE HELPERS FOR LIKED VIDEOS
     *****************************************/
    function getLikedVideosFromStorage() {
      const data = localStorage.getItem("likedVideos");
      return data ? JSON.parse(data) : [];
    }

    function saveLikedVideosToStorage(videos) {
      localStorage.setItem("likedVideos", JSON.stringify(videos));
    }

    function addLikedVideo(videoData) {
      const videos = getLikedVideosFromStorage();
      // Avoid duplicates
      if (!videos.find(v => v.videoId === videoData.videoId)) {
        videos.push(videoData);
        saveLikedVideosToStorage(videos);
      }
    }

    function removeLikedVideo(videoId) {
      let videos = getLikedVideosFromStorage();
      videos = videos.filter(v => v.videoId !== videoId);
      saveLikedVideosToStorage(videos);
    }

    /*****************************************
     * GLOBAL VARIABLES & CONFIGURATION
     *****************************************/
    let players = [];         // Array to store YT.Player objects
    let playerIdCounter = 0;  // Unique ID counter for players
    const API_KEY = 'AIzaSyAK7FK5VPVKea0cxj2kqCDiwl92fjYLXVs';  // Replace with your own API key
    const SEARCH_QUERIES = [
      "government news", "politics news", "news", 
      "elections news", "technology news", "conspiracy theories"
    ];
    // For comments – track which video is being commented on.
    let currentCommentVideoId = null;

    // Global cache to store pre-fetched videos
    let videoCache = [];

    /*****************************************
     * UTILITY: Shuffle an array (Fisher–Yates)
     *****************************************/
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /*****************************************
     * FETCH VIDEOS FROM YOUTUBE DATA API
     *****************************************/
    // Preload a large batch of videos and store in videoCache.
    async function preloadVideos(batchSize = 50) {
      const query = SEARCH_QUERIES[Math.floor(Math.random() * SEARCH_QUERIES.length)];
      const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=${batchSize}&q=${encodeURIComponent(query)}&key=${API_KEY}`;
      try {
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (searchData.items && searchData.items.length) {
          const videoIds = searchData.items.map(item => item.id.videoId).join(",");
          const videos = await fetchVideoDetails(videoIds);
          videoCache = shuffleArray(videos);
        }
      } catch (err) {
        console.error("Error preloading videos:", err);
      }
    }

    async function fetchVideoDetails(videoIds) {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&fields=items(id,snippet(channelId,title,channelTitle,thumbnails),statistics)&id=${videoIds}&key=${API_KEY}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.items) {
          return data.items.map(item => ({
            videoId: item.id,
            title: item.snippet.title,
            channelTitle: item.snippet.channelTitle,
            thumbnail: item.snippet.thumbnails.medium.url,
            statistics: item.statistics
          }));
        }
        return [];
      } catch (err) {
        console.error("Error fetching video details:", err);
        return [];
      }
    }

    // New function for searching videos by query
    async function searchVideos(query, count = 10) {
      const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=${count}&q=${encodeURIComponent(query)}&key=${API_KEY}`;
      try {
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (searchData.items && searchData.items.length) {
          const videoIds = searchData.items.map(item => item.id.videoId).join(",");
          return await fetchVideoDetails(videoIds);
        }
        return [];
      } catch (err) {
        console.error("Error searching videos:", err);
        return [];
      }
    }

    /*****************************************
     * CREATE A VIDEO CONTAINER ELEMENT
     *****************************************/
    function createVideoContainer(videoData, uniqueId) {
      const container = document.createElement("div");
      container.className = "video-container";
      // Save key video details as data attributes.
      container.dataset.videoId = videoData.videoId;
      container.dataset.title = videoData.title;
      container.dataset.channel = videoData.channelTitle;
      container.dataset.views = videoData.statistics.viewCount || "0";
      container.dataset.thumbnail = videoData.thumbnail;

      // Create placeholder for the YouTube IFrame.
      const playerDiv = document.createElement("div");
      playerDiv.id = "player-" + uniqueId;
      container.appendChild(playerDiv);

      // Overlay with video info, stats, and AI analysis.
      const info = document.createElement("div");
      info.className = "video-info";
      info.innerHTML = `
        <div class="user-info">
          <div class="user-avatar">
            <img src="${videoData.thumbnail}" alt="thumbnail" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
          </div>
          <div>
            <div class="username">@${videoData.channelTitle}</div>
            <div class="caption">${videoData.title}</div>
          </div>
        </div>
        <div class="video-stats">Views: ${videoData.statistics.viewCount || "0"}</div>
        <div class="ai-analysis">
          <div class="trust-score">
            <div class="trust-indicator high-trust"></div>
            <span>Rating in progress... <i class="fas fa-spinner loader"></i></span>
          </div>
          <div class="ai-explanation">
            <i class="fas fa-check-circle" style="color: var(--trust-high);"></i>
            Video from YouTube
          </div>
        </div>
        <div class="side-actions">
          <button class="action-button like-btn" data-video-id="${videoData.videoId}">
            <div class="action-icon"><i class="fas fa-heart"></i></div>
            <span class="action-count">0</span>
          </button>
          <button class="action-button comments-btn" data-video-id="${videoData.videoId}">
            <div class="action-icon"><i class="fas fa-comment"></i></div>
            <span class="action-count">0</span>
          </button>
          <button class="action-button fact-check" data-video-id="${videoData.videoId}">
            <div class="action-icon"><i class="fas fa-check-circle"></i></div>
            <span class="action-count">Verify</span>
          </button>
        </div>
      `;
      container.appendChild(info);
      return container;
    }

    /*****************************************
     * INITIALIZE A YOUTUBE PLAYER
     *****************************************/
    function initPlayer(uniqueId, videoData) {
      const player = new YT.Player("player-" + uniqueId, {
        videoId: videoData.videoId,
        playerVars: {
          autoplay: 0,
          controls: 1,
          playsinline: 1,
          modestbranding: 1,
          rel: 0
        },
        events: {
          onReady: () => {
            const container = document.getElementById("player-" + uniqueId).closest('.video-container');
            player.container = container;
            players.push(player);
          },
          onError: (event) => {
            console.error("YT Player error:", event.data);
          }
        }
      });
    }

    /*****************************************
     * AUTOMATIC RATING UPDATE FUNCTION
     *****************************************/
    function updateVideoRating(container, videoData, forceUpdate = false) {
      const analysis = container.querySelector(".ai-analysis");
      const trustScoreSpan = analysis.querySelector(".trust-score span");
      const explanationDiv = analysis.querySelector(".ai-explanation");
      
      // Check for cached values (via cookies)
      const cachedRating = getCookie("rating_" + videoData.videoId);
      const cachedExplanation = getCookie("explanation_" + videoData.videoId);
      
      if (cachedRating && cachedExplanation && !forceUpdate) {
        trustScoreSpan.textContent = `Trust Score: ${cachedRating}%`;
        updateTrustIndicator(trustScoreSpan, Number(cachedRating));
        explanationDiv.textContent = cachedExplanation;
      } else {
        trustScoreSpan.innerHTML = `Rating in progress... <i class="fas fa-spinner loader"></i>`;
        explanationDiv.textContent = "";
        // Call the new function to get both rating and explanation.
        getGeminiRatingAndExplanation(videoData, forceUpdate).then(result => {
          // Animate the trust score update.
          animateRating(trustScoreSpan, 0, result.rating, 1000);
          // After the animation, update the explanation text.
          setTimeout(() => {
            explanationDiv.textContent = result.explanation;
          }, 1000);
        });
      }
    }

    /*****************************************
     * APPEND NEW VIDEOS FROM CACHE
     *****************************************/
    async function appendRandomVideos(count = 5) {
      // If our cache is low, preload more videos.
      if (videoCache.length < count) {
        await preloadVideos(50);
      }
      const videosToAppend = videoCache.splice(0, count);
      const videosContainer = document.getElementById("videos");
      for (const videoData of videosToAppend) {
        const uniqueId = playerIdCounter++;
        const container = createVideoContainer(videoData, uniqueId);
        videosContainer.appendChild(container);
        initPlayer(uniqueId, videoData);
        if (videoObserver) {
          videoObserver.observe(container);
        }
        // Update UI based on stored like/comment cookies.
        const likeCookie = getCookie("like_" + videoData.videoId);
        if (likeCookie === "true") {
          const likeBtn = container.querySelector(".like-btn");
          likeBtn.classList.add("liked");
          likeBtn.querySelector(".action-count").textContent = "1";
        }
        const commentCookie = getCookie("comments_" + videoData.videoId);
        if (commentCookie) {
          try {
            const commentsArr = JSON.parse(commentCookie);
            const commentBtn = container.querySelector(".comments-btn");
            commentBtn.querySelector(".action-count").textContent = commentsArr.length;
          } catch (e) {
            console.error("Error parsing comments cookie:", e);
          }
        }
        updateVideoRating(container, videoData);
      }
    }

    /*****************************************
     * AUTO-PLAY / PAUSE VIA INTERSECTION OBSERVER
     *****************************************/
    let videoObserver;
    function initVideoObserver() {
      const options = { root: null, threshold: 0.8 };
      videoObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          players.forEach(p => {
            if (p.container === entry.target) {
              entry.isIntersecting ? p.playVideo() : p.pauseVideo();
            }
          });
        });
      }, options);
      document.querySelectorAll('.video-container').forEach(container => {
        videoObserver.observe(container);
      });
    }

    /*****************************************
     * DYNAMIC RATING ANIMATION FUNCTIONS
     *****************************************/
    function animateRating(ratingElement, start, end, duration) {
      let startTime = null;
      function step(timestamp) {
        if (!startTime) startTime = timestamp;
        const progress = timestamp - startTime;
        const progressRatio = Math.min(progress / duration, 1);
        const currentValue = Math.round(start + (end - start) * progressRatio);
        ratingElement.textContent = `Trust Score: ${currentValue}%`;
        if (progress < duration) {
          window.requestAnimationFrame(step);
        } else {
          ratingElement.textContent = `Trust Score: ${end}%`;
          updateTrustIndicator(ratingElement, end);
        }
      }
      window.requestAnimationFrame(step);
    }

    function updateTrustIndicator(ratingElement, rating) {
      const trustIndicator = ratingElement.parentElement.querySelector('.trust-indicator');
      if (!trustIndicator) return;
      trustIndicator.classList.remove("high-trust", "medium-trust", "low-trust");
      if (rating >= 80) {
        trustIndicator.classList.add("high-trust");
      } else if (rating >= 50) {
        trustIndicator.classList.add("medium-trust");
      } else {
        trustIndicator.classList.add("low-trust");
      }
    }

    /*****************************************
     * GEMINI AI RATING FUNCTION (with force refresh)
     *****************************************/
    
    async function getGeminiRatingAndExplanation(videoData, forceUpdate = false) {
      // If not forcing an update, check for cached rating and explanation
      if (!forceUpdate) {
        const cachedRating = getCookie("rating_" + videoData.videoId);
        const cachedExplanation = getCookie("explanation_" + videoData.videoId);
        if (cachedRating && cachedExplanation) {
          return { rating: Number(cachedRating), explanation: cachedExplanation };
        }
      }
      
      // Get current date and time for extra context
      const now = new Date();
      const currentDateString = now.toLocaleDateString('en-US', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      });
    
      // Set up the Gemini API call (replace geminiApiKey with your valid key if needed)
      const geminiModel = 'gemini-2.0-flash-thinking-exp-01-21';
      const geminiApiKey = 'AIzaSyCnMRMwFGVlPufyLDdEpFG4clySwFB3dBc';
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${geminiApiKey}`;
      
      // Build a prompt that includes extra context such as the current date and time.
      // The output is expected to have the rating on the first line and the explanation on the following lines.
      const promptText = `Please evaluate the following YouTube video for credibility, factual accuracy, and trustworthiness.
    
    Video Title: "${videoData.title}"
    Channel: "${videoData.channelTitle}"
    Thumbnail URL: ${videoData.thumbnail}
    Description: ${videoData.description || "No description available."}
    Published At: ${videoData.publishedAt || "Unknown"}
    Views: ${videoData.statistics.viewCount || "0"}
    Likes: ${videoData.statistics.likeCount || "N/A"}
    Comments: ${videoData.statistics.commentCount || "N/A"}
    
    Evaluation Context:
    Current Date: ${currentDateString}
    
    Provide on the first line a numeric rating from 0 (not credible) to 100 (highly credible).
    On the following lines, give a concise explanation (50 words or less) for the rating.`;
    
      const promptPayload = {
        contents: [
          {
            parts: [
              { text: promptText }
            ]
          }
        ]
      };
    
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(promptPayload)
        });
        if (!response.ok) {
          throw new Error(`API responded with status: ${response.status}`);
        }
        const data = await response.json();
        if (!data.candidates || data.candidates.length === 0) {
          throw new Error("Invalid response structure from Gemini API.");
        }
        
        // Parse the API response.
        // We expect the first line to contain the numeric rating, and the remaining lines to be the explanation.
        const output = data.candidates[0].content.parts[0].text;
        const lines = output.trim().split('\n').filter(line => line.trim() !== "");
        let rating = 0;
        let explanation = "";
        if (lines.length > 0) {
          const ratingMatch = lines[0].match(/(\d+(\.\d+)?)/);
          rating = ratingMatch ? Number(ratingMatch[1]) : 0;
          explanation = lines.slice(1).join(' ').trim();
        }
        
        // Cache the results in cookies (for 1 day)
        setCookie("rating_" + videoData.videoId, rating, 1);
        setCookie("explanation_" + videoData.videoId, explanation, 1);
        
        return { rating, explanation };
      } catch (error) {
        console.error("Error getting Gemini rating and explanation:", error);
        return { rating: 0, explanation: "Error occurred while fetching explanation." };
      }
    }

    /*****************************************
     * COMMENTS FUNCTIONS
     *****************************************/
    function loadComments(videoId) {
      const commentsList = document.getElementById("commentsList");
      commentsList.innerHTML = "";
      const commentCookie = getCookie("comments_" + videoId);
      let comments = [];
      if (commentCookie) {
        try {
          comments = JSON.parse(commentCookie);
        } catch (e) {
          console.error("Error parsing comments cookie:", e);
        }
      }
      comments.forEach(comment => {
        const commentEl = document.createElement("div");
        commentEl.className = "comment";
        commentEl.innerHTML = `
          <div class="comment-avatar"><i class="fas fa-user"></i></div>
          <div class="comment-content">
            <div class="comment-header">
              <span class="comment-username">You</span>
              <span class="comment-time">${new Date(comment.timestamp).toLocaleTimeString()}</span>
            </div>
            <div class="comment-text">${comment.text}</div>
          </div>
        `;
        commentsList.appendChild(commentEl);
      });
    }

    function updateCommentCount(videoId) {
      const commentCookie = getCookie("comments_" + videoId);
      let count = 0;
      if (commentCookie) {
        try {
          const comments = JSON.parse(commentCookie);
          count = comments.length;
        } catch (e) {
          console.error(e);
        }
      }
      const commentBtn = document.querySelector(`.comments-btn[data-video-id="${videoId}"]`);
      if (commentBtn) {
        commentBtn.querySelector(".action-count").textContent = count;
      }
    }

    /*****************************************
     * INTERACTIONS: LIKES, COMMENTS, FACT-CHECK & NAVIGATION
     *****************************************/
    function initInteractions() {
      document.addEventListener("click", (event) => {
        // Handle Like button toggle.
        if (event.target.closest(".like-btn")) {
          const btn = event.target.closest(".like-btn");
          const videoId = btn.dataset.videoId;
          const container = btn.closest(".video-container");
          const videoData = {
            videoId: container.dataset.videoId,
            title: container.dataset.title,
            channelTitle: container.dataset.channel,
            thumbnail: container.dataset.thumbnail,
            statistics: { viewCount: container.dataset.views }
          };
          if (getCookie("like_" + videoId) === "true") {
            eraseCookie("like_" + videoId);
            btn.classList.remove("liked");
            btn.querySelector(".action-count").textContent = "0";
            removeLikedVideo(videoId);
          } else {
            setCookie("like_" + videoId, "true", 30);
            btn.classList.add("liked");
            btn.querySelector(".action-count").textContent = "1";
            addLikedVideo(videoData);
          }
        }

        // Open comments section.
        if (event.target.closest(".comments-btn")) {
          const btn = event.target.closest(".comments-btn");
          currentCommentVideoId = btn.dataset.videoId;
          loadComments(currentCommentVideoId);
          document.getElementById("commentsSection").classList.add("show");
        }

        // Fact-check: force update the Gemini rating.
        if (event.target.closest(".fact-check")) {
          const button = event.target.closest(".fact-check");
          const container = button.closest(".video-container");
          const videoData = {
            videoId: container.dataset.videoId,
            title: container.dataset.title,
            channelTitle: container.dataset.channel,
            statistics: { viewCount: container.dataset.views }
          };
          updateVideoRating(container, videoData, true);
        }

        // Navigation: open Search and Liked Videos modals.
        if (event.target.closest("#navSearch")) {
          document.getElementById("searchSection").classList.add("show");
        }
        if (event.target.closest("#navLiked")) {
          loadLikedVideos();
          document.getElementById("likedVideosSection").classList.add("show");
        }

        // Clicking a liked video scrolls to or appends it.
        if (event.target.closest(".liked-video")) {
          const likedVideoEl = event.target.closest(".liked-video");
          const videoId = likedVideoEl.dataset.videoId;
          const existingContainer = document.querySelector(`.video-container[data-video-id="${videoId}"]`);
          if (existingContainer) {
            existingContainer.scrollIntoView({ behavior: "smooth" });
          } else {
            appendVideoToFeed(videoId, likedVideoEl.dataset);
          }
          document.getElementById("likedVideosSection").classList.remove("show");
        }

        // Clicking a search result.
        if (event.target.closest(".search-result")) {
          const resultEl = event.target.closest(".search-result");
          const videoId = resultEl.dataset.videoId;
          const existingContainer = document.querySelector(`.video-container[data-video-id="${videoId}"]`);
          if (existingContainer) {
            existingContainer.scrollIntoView({ behavior: "smooth" });
          } else {
            const videoData = {
              videoId: resultEl.dataset.videoId,
              title: resultEl.dataset.title,
              channelTitle: resultEl.dataset.channel,
              thumbnail: resultEl.dataset.thumbnail,
              statistics: { viewCount: resultEl.dataset.views }
            };
            appendVideoToFeedObj(videoData);
          }
          document.getElementById("searchSection").classList.remove("show");
        }
      });

      // Close modals.
      document.getElementById("closeComments").addEventListener("click", () => {
        document.getElementById("commentsSection").classList.remove("show");
      });
      document.getElementById("closeLikedVideos").addEventListener("click", () => {
        document.getElementById("likedVideosSection").classList.remove("show");
      });
      document.getElementById("closeSearch").addEventListener("click", () => {
        document.getElementById("searchSection").classList.remove("show");
      });

      // Post a new comment.
      document.getElementById("submitComment").addEventListener("click", () => {
        const input = document.getElementById("commentInput");
        const text = input.value.trim();
        if (!text || !currentCommentVideoId) return;
        const commentCookie = getCookie("comments_" + currentCommentVideoId);
        let comments = [];
        if (commentCookie) {
          try {
            comments = JSON.parse(commentCookie);
          } catch (e) {
            console.error(e);
          }
        }
        comments.push({ text, timestamp: Date.now() });
        setCookie("comments_" + currentCommentVideoId, JSON.stringify(comments), 30);
        input.value = "";
        loadComments(currentCommentVideoId);
        updateCommentCount(currentCommentVideoId);
      });

      // Execute search.
      document.getElementById("executeSearch").addEventListener("click", async () => {
        const query = document.getElementById("searchInput").value.trim();
        if (!query) return;
        const results = await searchVideos(query, 10);
        displaySearchResults(results);
      });
    }

    // Append video to feed from videoData.
    function appendVideoToFeedObj(videoData) {
      const videosContainer = document.getElementById("videos");
      const uniqueId = playerIdCounter++;
      const container = createVideoContainer(videoData, uniqueId);
      videosContainer.prepend(container);
      initPlayer(uniqueId, videoData);
      if (videoObserver) {
        videoObserver.observe(container);
      }
      updateVideoRating(container, videoData);
    }

    async function appendVideoToFeed(videoId, dataAttrs = {}) {
      if (dataAttrs && dataAttrs.title && dataAttrs.channel) {
        const videoData = {
          videoId: dataAttrs.videoId,
          title: dataAttrs.title,
          channelTitle: dataAttrs.channel,
          thumbnail: dataAttrs.thumbnail,
          statistics: { viewCount: dataAttrs.views || "0" }
        };
        appendVideoToFeedObj(videoData);
      } else {
        const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoId}&key=${API_KEY}`;
        try {
          const res = await fetch(url);
          const data = await res.json();
          if (data.items && data.items.length) {
            const item = data.items[0];
            const videoData = {
              videoId: item.id,
              title: item.snippet.title,
              channelTitle: item.snippet.channelTitle,
              thumbnail: item.snippet.thumbnails.medium.url,
              statistics: item.statistics
            };
            appendVideoToFeedObj(videoData);
          }
        } catch (err) {
          console.error("Error appending video to feed:", err);
        }
      }
    }

    function loadLikedVideos() {
      const likedVideosList = document.getElementById("likedVideosList");
      likedVideosList.innerHTML = "";
      const likedVideos = getLikedVideosFromStorage();
      if (likedVideos.length === 0) {
        likedVideosList.innerHTML = "<p>No liked videos yet.</p>";
        return;
      }
      likedVideos.forEach(video => {
        const videoEl = document.createElement("div");
        videoEl.className = "liked-video";
        videoEl.dataset.videoId = video.videoId;
        videoEl.innerHTML = `
          <img src="${video.thumbnail}" alt="thumbnail" class="liked-video-thumbnail">
          <div class="liked-video-info">
            <div class="liked-video-title">${video.title}</div>
            <div class="liked-video-channel">@${video.channelTitle}</div>
          </div>
        `;
        likedVideosList.appendChild(videoEl);
      });
    }

    function displaySearchResults(results) {
      const searchResults = document.getElementById("searchResults");
      searchResults.innerHTML = "";
      if (results.length === 0) {
        searchResults.innerHTML = "<p style='color: var(--text);'>No results found.</p>";
        return;
      }
      results.forEach(video => {
        const resultEl = document.createElement("div");
        resultEl.className = "search-result";
        resultEl.dataset.videoId = video.videoId;
        resultEl.dataset.title = video.title;
        resultEl.dataset.channel = video.channelTitle;
        resultEl.dataset.thumbnail = video.thumbnail;
        resultEl.dataset.views = video.statistics.viewCount || "0";
        resultEl.innerHTML = `
          <img src="${video.thumbnail}" alt="thumbnail" class="search-result-thumbnail">
          <div class="search-result-info">
            <div class="search-result-title">${video.title}</div>
            <div class="search-result-channel">@${video.channelTitle}</div>
          </div>
        `;
        searchResults.appendChild(resultEl);
      });
    }

    /*****************************************
     * SENTINEL OBSERVER FOR INFINITE SCROLL
     *****************************************/
    function initSentinelObserver() {
      const sentinel = document.getElementById("sentinel");
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            appendRandomVideos(5);
          }
        });
      });
      observer.observe(sentinel);
    }

    /*****************************************
     * INITIALIZATION WHEN YOUTUBE IFRAME API IS READY
     *****************************************/
    function onYouTubeIframeAPIReady() {
      // Start by appending an initial batch of videos.
      appendRandomVideos(10);
      initVideoObserver();
      initSentinelObserver();
      initInteractions();
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
  </script>
</body>
</html>
