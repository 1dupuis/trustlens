<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>trustlens</title>
  <!-- Font Awesome & Animate.css for icons/animations -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root {
      --primary: #fe2c55;
      --primary-hover: #ff4d70;
      --secondary: #25f4ee;
      --background: #121212;
      --surface: #1e1e1e;
      --text: #ffffff;
      --text-secondary: #a8a8a8;
      --trust-high: #22c55e;
      --trust-medium: #f59e0b;
      --trust-low: #ef4444;
      --glass-bg: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.05);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--background);
      color: var(--text);
      line-height: 1.5;
      overflow: hidden;
    }

    /* Main scrollable container */
    .app-container {
      max-width: 100%;
      margin: 0 auto;
      height: 100vh;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      position: relative;
    }

    /* Container for video posts */
    #videos {
      display: flex;
      flex-direction: column;
    }

    .video-container {
      height: 100vh;
      scroll-snap-align: start;
      position: relative;
      background: var(--surface);
      overflow: hidden;
    }

    /* The YouTube IFrame fills the container */
    .video-container iframe {
      width: 100%;
      height: 100%;
    }

    .video-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 24px;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      backdrop-filter: blur(10px);
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 6px;
    }

    .user-avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--glass-bg);
      border: 2px solid var(--primary);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .username {
      font-weight: 600;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .caption {
      margin-bottom: 6px;
      font-size: 1rem;
      line-height: 1.5;
    }

    .video-stats {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .ai-analysis {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 16px;
      backdrop-filter: blur(12px);
      animation: fadeIn 0.3s ease;
    }

    .trust-score {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-weight: 500;
    }

    .trust-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      position: relative;
    }
    .trust-indicator::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      background: inherit;
      opacity: 0.3;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.3; }
      50% { transform: scale(1.5); opacity: 0.1; }
      100% { transform: scale(1); opacity: 0.3; }
    }
    .high-trust { background: var(--trust-high); }
    .medium-trust { background: var(--trust-medium); }
    .low-trust { background: var(--trust-low); }

    .ai-explanation {
      font-size: 0.95rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .side-actions {
      position: absolute;
      right: 16px;
      bottom: 180px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      z-index: 10;
    }

    .action-button {
      background: none;
      border: none;
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .action-button:hover { transform: scale(1.1); }
    .action-button:active { transform: scale(0.95); }
    .action-icon {
      width: 48px;
      height: 48px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      backdrop-filter: blur(12px);
      transition: all 0.2s ease;
    }
    /* When a like button is “liked” */
    .action-button.like-btn.liked .action-icon {
      background: var(--primary);
      border-color: var(--primary-hover);
      color: var(--trust-high);
    }
    .action-button:hover .action-icon {
      background: var(--primary);
      border-color: var(--primary-hover);
    }
    .action-count {
      font-size: 0.85rem;
      font-weight: 500;
    }

    /* Navigation Bar */
    .navigation {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: var(--surface);
      display: flex;
      justify-content: space-around;
      align-items: center;
      z-index: 100;
      border-top: 1px solid var(--glass-border);
      backdrop-filter: blur(12px);
    }
    .nav-item {
      color: var(--text-secondary);
      text-decoration: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: 0.75rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    .nav-item:hover {
      color: var(--text);
      transform: translateY(-2px);
    }
    .nav-icon { font-size: 1.2rem; }
    .active { color: var(--primary); }

    /* Comments Section (existing) */
    .comments-section {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70%;
      background: var(--surface);
      border-radius: 20px 20px 0 0;
      padding: 24px;
      transform: translateY(100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      overflow-y: auto;
    }
    .comments-section.show { transform: translateY(0); }
    .comments-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--glass-border);
    }
    .comments-title { font-weight: 600; font-size: 1.1rem; }
    .close-comments {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      padding: 8px;
    }
    /* Comments list – dynamically generated */
    #commentsList {
      max-height: 60%;
      overflow-y: auto;
      margin-bottom: 16px;
    }
    .comment {
      display: flex;
      gap: 16px;
      margin-bottom: 24px;
      animation: slideInUp 0.3s ease;
    }
    .comment-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--glass-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
    }
    .comment-content { flex: 1; }
    .comment-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }
    .comment-username { font-weight: 600; font-size: 0.9rem; }
    .comment-time {
      color: var(--text-secondary);
      font-size: 0.8rem;
    }
    .comment-text {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    .new-comment {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .new-comment input {
      flex: 1;
      padding: 8px;
      border-radius: 4px;
      border: none;
      outline: none;
    }
    .new-comment button {
      padding: 8px 12px;
      border: none;
      background: var(--primary);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .new-comment button:hover {
      background: var(--primary-hover);
    }

    /* Liked Videos Modal */
    .liked-videos-section {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70%;
      background: var(--surface);
      border-radius: 20px 20px 0 0;
      padding: 24px;
      transform: translateY(100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      overflow-y: auto;
    }
    .liked-videos-section.show { transform: translateY(0); }
    .liked-videos-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--glass-border);
    }
    .liked-videos-title { font-weight: 600; font-size: 1.1rem; }
    .close-liked-videos {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      padding: 8px;
    }
    #likedVideosList .liked-video {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid var(--glass-border);
      cursor: pointer;
    }
    #likedVideosList .liked-video:hover {
      background: var(--glass-bg);
    }
    .liked-video-thumbnail {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      object-fit: cover;
    }
    .liked-video-info {
      flex: 1;
    }
    .liked-video-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .liked-video-channel {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    /* Search Modal */
    .search-section {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      padding: 24px;
      transform: translateY(-100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
    }
    .search-section.show { transform: translateY(0); }
    .search-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .search-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text);
    }
    .close-search {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 1.2rem;
      padding: 8px;
    }
    .search-input-container {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .search-input-container input {
      flex: 1;
      padding: 8px;
      border-radius: 4px;
      border: none;
      outline: none;
    }
    .search-input-container button {
      padding: 8px 12px;
      border: none;
      background: var(--primary);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .search-input-container button:hover {
      background: var(--primary-hover);
    }
    #searchResults {
      overflow-y: auto;
      flex: 1;
    }
    .search-result {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid var(--glass-border);
      cursor: pointer;
    }
    .search-result:hover {
      background: var(--glass-bg);
    }
    .search-result-thumbnail {
      width: 80px;
      height: 45px;
      border-radius: 4px;
      object-fit: cover;
    }
    .search-result-info {
      flex: 1;
      color: var(--text);
    }
    .search-result-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .search-result-channel {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    .loader {
      width: 24px;
      height: 24px;
      border: 3px solid var(--text);
      border-bottom-color: transparent;
      border-radius: 50%;
      display: inline-block;
      animation: rotation 1s linear infinite;
    }
    @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <!-- Main app container -->
  <div class="app-container">
    <div id="videos"></div>
    <div id="sentinel"></div>
  </div>

  <!-- Comments Section (existing) -->
  <div class="comments-section" id="commentsSection">
    <div class="comments-header">
      <div class="comments-title">Comments</div>
      <button class="close-comments" id="closeComments"><i class="fas fa-times"></i></button>
    </div>
    <div id="commentsList">
      <!-- Comments will be inserted here -->
    </div>
    <div class="new-comment">
      <input type="text" id="commentInput" placeholder="Add a comment..." />
      <button id="submitComment">Post</button>
    </div>
  </div>

  <!-- Liked Videos Section -->
  <div class="liked-videos-section" id="likedVideosSection">
    <div class="liked-videos-header">
      <div class="liked-videos-title">Liked Videos</div>
      <button class="close-liked-videos" id="closeLikedVideos"><i class="fas fa-times"></i></button>
    </div>
    <div id="likedVideosList">
      <!-- Liked videos will be loaded here -->
    </div>
  </div>

  <!-- Search Section -->
  <div class="search-section" id="searchSection">
    <div class="search-header">
      <div class="search-title">Search Videos</div>
      <button class="close-search" id="closeSearch"><i class="fas fa-times"></i></button>
    </div>
    <div class="search-input-container">
      <input type="text" id="searchInput" placeholder="Enter search query..." />
      <button id="executeSearch">Search</button>
    </div>
    <div id="searchResults">
      <!-- Search results will be displayed here -->
    </div>
  </div>

  <!-- Navigation Bar -->
  <div class="navigation">
    <a href="#" class="nav-item active" id="navHome">
      <i class="fas fa-home nav-icon"></i>
      <span>Home</span>
    </a>
    <a href="#" class="nav-item" id="navSearch">
      <i class="fas fa-search nav-icon"></i>
      <span>Search</span>
    </a>
    <a href="#" class="nav-item" id="navLiked">
      <i class="fas fa-heart nav-icon"></i>
      <span>Liked</span>
    </a>
  </div>

  <!-- Load the YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    /*****************************************
     * COOKIE HELPER FUNCTIONS (with encoding)
     *****************************************/
    function setCookie(name, value, days) {
      let expires = "";
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + expires + "; path=/";
    }

    function getCookie(name) {
      const nameEQ = encodeURIComponent(name) + "=";
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i].trim();
        if (c.indexOf(nameEQ) === 0) {
          return decodeURIComponent(c.substring(nameEQ.length));
        }
      }
      return null;
    }

    function eraseCookie(name) {   
      document.cookie = encodeURIComponent(name) + '=; Max-Age=-99999999; path=/';
    }

    /*****************************************
     * LOCAL STORAGE HELPERS FOR LIKED VIDEOS
     *****************************************/
    function getLikedVideosFromStorage() {
      const data = localStorage.getItem("likedVideos");
      return data ? JSON.parse(data) : [];
    }

    function saveLikedVideosToStorage(videos) {
      localStorage.setItem("likedVideos", JSON.stringify(videos));
    }

    function addLikedVideo(videoData) {
      const videos = getLikedVideosFromStorage();
      // Avoid duplicates
      if (!videos.find(v => v.videoId === videoData.videoId)) {
        videos.push(videoData);
        saveLikedVideosToStorage(videos);
      }
    }

    function removeLikedVideo(videoId) {
      let videos = getLikedVideosFromStorage();
      videos = videos.filter(v => v.videoId !== videoId);
      saveLikedVideosToStorage(videos);
    }

    /*****************************************
     * GLOBAL VARIABLES & CONFIGURATION
     *****************************************/
    let players = [];         // Array to store YT.Player objects
    let playerIdCounter = 0;  // Unique ID counter for players
    const API_KEY = 'AIzaSyAK7FK5VPVKea0cxj2kqCDiwl92fjYLXVs';  // Replace with your own API key SECONDARY IF NOT WORKING: AIzaSyCTePB1WLpoveNVjyncJ_uCmVutawmUaM0
    const SEARCH_QUERIES = [
      "government news", "politics news", "news", 
      "elections news", "technology news", "conspiracy theories"
    ];
    // For comments – track which video is being commented on.
    let currentCommentVideoId = null;

    /*****************************************
     * UTILITY: Shuffle an array (Fisher–Yates)
     *****************************************/
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /*****************************************
     * FETCH VIDEOS FROM YOUTUBE DATA API
     *****************************************/
    async function getRandomVideos(count) {
      const query = SEARCH_QUERIES[Math.floor(Math.random() * SEARCH_QUERIES.length)];
      const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=2&q=${encodeURIComponent(query)}&key=${API_KEY}`;
      try {
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (searchData.items && searchData.items.length) {
          const selected = shuffleArray(searchData.items).slice(0, count);
          const videoIds = selected.map(item => item.id.videoId).join(",");
          return await fetchVideoDetails(videoIds);
        }
        return [];
      } catch (err) {
        console.error("Error fetching videos:", err);
        return [];
      }
    }

    async function fetchVideoDetails(videoIds) {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&fields=items(id,snippet(channelId,title,channelTitle,thumbnails),statistics)&id=${videoIds}&key=${API_KEY}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.items) {
          return data.items.map(item => ({
            videoId: item.id,
            title: item.snippet.title,
            channelTitle: item.snippet.channelTitle,
            thumbnail: item.snippet.thumbnails.medium.url,
            statistics: item.statistics
          }));
        }
        return [];
      } catch (err) {
        console.error("Error fetching video details:", err);
        return [];
      }
    }

    // New function for searching videos by query
    async function searchVideos(query, count = 10) {
      const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=${count}&q=${encodeURIComponent(query)}&key=${API_KEY}`;
      try {
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();
        if (searchData.items && searchData.items.length) {
          const videoIds = searchData.items.map(item => item.id.videoId).join(",");
          return await fetchVideoDetails(videoIds);
        }
        return [];
      } catch (err) {
        console.error("Error searching videos:", err);
        return [];
      }
    }

    /*****************************************
     * CREATE A VIDEO CONTAINER ELEMENT
     *****************************************/
    function createVideoContainer(videoData, uniqueId) {
      const container = document.createElement("div");
      container.className = "video-container";
      // Save key video details as data attributes.
      container.dataset.videoId = videoData.videoId;
      container.dataset.title = videoData.title;
      container.dataset.channel = videoData.channelTitle;
      container.dataset.views = videoData.statistics.viewCount || "0";
      container.dataset.thumbnail = videoData.thumbnail;

      // Create placeholder for the YouTube IFrame.
      const playerDiv = document.createElement("div");
      playerDiv.id = "player-" + uniqueId;
      container.appendChild(playerDiv);

      // Overlay with video info, stats, and AI analysis.
      const info = document.createElement("div");
      info.className = "video-info";
      info.innerHTML = `
        <div class="user-info">
          <div class="user-avatar">
            <img src="${videoData.thumbnail}" alt="thumbnail" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
          </div>
          <div>
            <div class="username">@${videoData.channelTitle}</div>
            <div class="caption">${videoData.title}</div>
          </div>
        </div>
        <div class="video-stats">Views: ${videoData.statistics.viewCount || "0"}</div>
        <div class="ai-analysis">
          <div class="trust-score">
            <div class="trust-indicator high-trust"></div>
            <span>Rating in progress... <i class="fas fa-spinner loader"></i></span>
          </div>
          <div class="ai-explanation">
            <i class="fas fa-check-circle" style="color: var(--trust-high);"></i>
            Video from YouTube
          </div>
        </div>
        <div class="side-actions">
          <button class="action-button like-btn" data-video-id="${videoData.videoId}">
            <div class="action-icon"><i class="fas fa-heart"></i></div>
            <span class="action-count">0</span>
          </button>
          <button class="action-button comments-btn" data-video-id="${videoData.videoId}">
            <div class="action-icon"><i class="fas fa-comment"></i></div>
            <span class="action-count">0</span>
          </button>
          <button class="action-button fact-check" data-video-id="${videoData.videoId}">
            <div class="action-icon"><i class="fas fa-check-circle"></i></div>
            <span class="action-count">Verify</span>
          </button>
        </div>
      `;
      container.appendChild(info);
      return container;
    }

    /*****************************************
     * INITIALIZE A YOUTUBE PLAYER
     *****************************************/
    function initPlayer(uniqueId, videoData) {
      const player = new YT.Player("player-" + uniqueId, {
        videoId: videoData.videoId,
        playerVars: {
          autoplay: 0,
          controls: 1,
          playsinline: 1,
          modestbranding: 1,
          rel: 0
        },
        events: {
          onReady: () => {
            const container = document.getElementById("player-" + uniqueId).closest('.video-container');
            player.container = container;
            players.push(player);
          },
          onError: (event) => {
            console.error("YT Player error:", event.data);
          }
        }
      });
    }

    /*****************************************
     * AUTOMATIC RATING UPDATE FUNCTION
     *****************************************/
    function updateVideoRating(container, videoData, forceUpdate = false) {
      const analysis = container.querySelector(".ai-analysis");
      const ratingSpan = analysis.querySelector(".trust-score span");
      const cachedRating = getCookie("rating_" + videoData.videoId);
      if (cachedRating && !forceUpdate) {
        ratingSpan.textContent = `Trust Score: ${cachedRating}%`;
        updateTrustIndicator(ratingSpan, Number(cachedRating));
      } else {
        ratingSpan.innerHTML = `Rating in progress... <i class="fas fa-spinner loader"></i>`;
        getGeminiRating(videoData, forceUpdate).then(newRating => {
          animateRating(ratingSpan, 0, newRating, 1000);
        });
      }
    }

    /*****************************************
     * APPEND NEW RANDOM VIDEOS
     *****************************************/
    async function appendRandomVideos(count = 5) {
      const videos = await getRandomVideos(count);
      const videosContainer = document.getElementById("videos");
      for (const videoData of videos) {
        const uniqueId = playerIdCounter++;
        const container = createVideoContainer(videoData, uniqueId);
        videosContainer.appendChild(container);
        initPlayer(uniqueId, videoData);
        if (videoObserver) {
          videoObserver.observe(container);
        }
        // Update UI based on stored like/comment cookies.
        const likeCookie = getCookie("like_" + videoData.videoId);
        if (likeCookie === "true") {
          const likeBtn = container.querySelector(".like-btn");
          likeBtn.classList.add("liked");
          likeBtn.querySelector(".action-count").textContent = "1";
        }
        const commentCookie = getCookie("comments_" + videoData.videoId);
        if (commentCookie) {
          try {
            const commentsArr = JSON.parse(commentCookie);
            const commentBtn = container.querySelector(".comments-btn");
            commentBtn.querySelector(".action-count").textContent = commentsArr.length;
          } catch (e) {
            console.error("Error parsing comments cookie:", e);
          }
        }
        updateVideoRating(container, videoData);
      }
    }

    /*****************************************
     * AUTO-PLAY / PAUSE VIA INTERSECTION OBSERVER
     *****************************************/
    let videoObserver;
    function initVideoObserver() {
      const options = { root: null, threshold: 0.8 };
      videoObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          players.forEach(p => {
            if (p.container === entry.target) {
              entry.isIntersecting ? p.playVideo() : p.pauseVideo();
            }
          });
        });
      }, options);
      document.querySelectorAll('.video-container').forEach(container => {
        videoObserver.observe(container);
      });
    }

    /*****************************************
     * DYNAMIC RATING ANIMATION FUNCTIONS
     *****************************************/
    function animateRating(ratingElement, start, end, duration) {
      let startTime = null;
      function step(timestamp) {
        if (!startTime) startTime = timestamp;
        const progress = timestamp - startTime;
        const progressRatio = Math.min(progress / duration, 1);
        const currentValue = Math.round(start + (end - start) * progressRatio);
        ratingElement.textContent = `Trust Score: ${currentValue}%`;
        if (progress < duration) {
          window.requestAnimationFrame(step);
        } else {
          ratingElement.textContent = `Trust Score: ${end}%`;
          updateTrustIndicator(ratingElement, end);
        }
      }
      window.requestAnimationFrame(step);
    }

    function updateTrustIndicator(ratingElement, rating) {
      const trustIndicator = ratingElement.parentElement.querySelector('.trust-indicator');
      if (!trustIndicator) return;
      trustIndicator.classList.remove("high-trust", "medium-trust", "low-trust");
      if (rating >= 80) {
        trustIndicator.classList.add("high-trust");
      } else if (rating >= 50) {
        trustIndicator.classList.add("medium-trust");
      } else {
        trustIndicator.classList.add("low-trust");
      }
    }

    /*****************************************
     * GEMINI AI RATING FUNCTION (with force refresh)
     *****************************************/
    async function getGeminiRating(videoData, forceUpdate = false) {
      // Check for a cached rating unless a force update is requested.
      if (!forceUpdate) {
        const cached = getCookie("rating_" + videoData.videoId);
        if (cached) return Number(cached);
      }
    
      const geminiModel = 'gemini-2.0-flash';
      const geminiApiKey = 'AIzaSyCnMRMwFGVlPufyLDdEpFG4clySwFB3dBc';
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${geminiApiKey}`;
    
      // Build a richer prompt that references the thumbnail and additional data.
      const promptText = `Please evaluate the following YouTube video for credibility, factual accuracy, and trustworthiness.
    
    Video Title: "${videoData.title}"
    Channel: "${videoData.channelTitle}"
    Thumbnail URL: ${videoData.thumbnail}
    Description: ${videoData.description || "No description available."}
    Published At: ${videoData.publishedAt || "Unknown"}
    Views: ${videoData.statistics.viewCount || "0"}
    Likes: ${videoData.statistics.likeCount || "N/A"}
    Comments: ${videoData.statistics.commentCount || "N/A"}
    
    Provide only a numeric rating from 0 (not credible) to 100 (highly credible).`;
    
      const prompt = {
        contents: [
          {
            parts: [
              {
                text: promptText
              }
            ]
          }
        ]
      };
    
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(prompt)
        });
        if (!response.ok) {
          throw new Error(`API responded with status: ${response.status}`);
        }
        const data = await response.json();
        if (!data.candidates || data.candidates.length === 0) {
          throw new Error("Invalid response structure from Gemini API.");
        }
        const output = data.candidates[0]?.content?.parts?.[0]?.text || "";
        const match = output.match(/(\d+(\.\d+)?)/);
        let rating = match ? Number(match[1]) : 0;
        if (rating >= 0 && rating <= 100) {
          setCookie("rating_" + videoData.videoId, rating, 1);
          return rating;
        }
        return 0;
      } catch (error) {
        console.error("Error getting Gemini rating:", error);
        return 0;
      }
    }

    /*****************************************
     * COMMENTS FUNCTIONS
     *****************************************/
    function loadComments(videoId) {
      const commentsList = document.getElementById("commentsList");
      commentsList.innerHTML = "";
      const commentCookie = getCookie("comments_" + videoId);
      let comments = [];
      if (commentCookie) {
        try {
          comments = JSON.parse(commentCookie);
        } catch (e) {
          console.error("Error parsing comments cookie:", e);
        }
      }
      comments.forEach(comment => {
        const commentEl = document.createElement("div");
        commentEl.className = "comment";
        commentEl.innerHTML = `
          <div class="comment-avatar"><i class="fas fa-user"></i></div>
          <div class="comment-content">
            <div class="comment-header">
              <span class="comment-username">You</span>
              <span class="comment-time">${new Date(comment.timestamp).toLocaleTimeString()}</span>
            </div>
            <div class="comment-text">${comment.text}</div>
          </div>
        `;
        commentsList.appendChild(commentEl);
      });
    }

    function updateCommentCount(videoId) {
      const commentCookie = getCookie("comments_" + videoId);
      let count = 0;
      if (commentCookie) {
        try {
          const comments = JSON.parse(commentCookie);
          count = comments.length;
        } catch (e) {
          console.error(e);
        }
      }
      const commentBtn = document.querySelector(`.comments-btn[data-video-id="${videoId}"]`);
      if (commentBtn) {
        commentBtn.querySelector(".action-count").textContent = count;
      }
    }

    /*****************************************
     * INTERACTIONS: LIKES, COMMENTS, FACT-CHECK & NAVIGATION
     *****************************************/
    function initInteractions() {
      document.addEventListener("click", (event) => {
        // Handle Like button toggle.
        if (event.target.closest(".like-btn")) {
          const btn = event.target.closest(".like-btn");
          const videoId = btn.dataset.videoId;
          const container = btn.closest(".video-container");
          // Extract video data from container's dataset
          const videoData = {
            videoId: container.dataset.videoId,
            title: container.dataset.title,
            channelTitle: container.dataset.channel,
            thumbnail: container.dataset.thumbnail,
            statistics: { viewCount: container.dataset.views }
          };
          if (getCookie("like_" + videoId) === "true") {
            eraseCookie("like_" + videoId);
            btn.classList.remove("liked");
            btn.querySelector(".action-count").textContent = "0";
            removeLikedVideo(videoId);
          } else {
            setCookie("like_" + videoId, "true", 30);
            btn.classList.add("liked");
            btn.querySelector(".action-count").textContent = "1";
            addLikedVideo(videoData);
          }
        }

        // Handle Comments: open the comment section.
        if (event.target.closest(".comments-btn")) {
          const btn = event.target.closest(".comments-btn");
          currentCommentVideoId = btn.dataset.videoId;
          loadComments(currentCommentVideoId);
          document.getElementById("commentsSection").classList.add("show");
        }

        // Handle Fact-check: force update the Gemini rating.
        if (event.target.closest(".fact-check")) {
          const button = event.target.closest(".fact-check");
          const container = button.closest(".video-container");
          const videoData = {
            videoId: container.dataset.videoId,
            title: container.dataset.title,
            channelTitle: container.dataset.channel,
            statistics: { viewCount: container.dataset.views }
          };
          updateVideoRating(container, videoData, true);
        }

        // Handle navigation for Search and Liked Videos modals.
        if (event.target.closest("#navSearch")) {
          document.getElementById("searchSection").classList.add("show");
        }
        if (event.target.closest("#navLiked")) {
          loadLikedVideos();
          document.getElementById("likedVideosSection").classList.add("show");
        }

        // Handle clicking on a liked video in the liked videos modal.
        if (event.target.closest(".liked-video")) {
          const likedVideoEl = event.target.closest(".liked-video");
          const videoId = likedVideoEl.dataset.videoId;
          // If video exists in the feed, scroll to it; else append it.
          const existingContainer = document.querySelector(`.video-container[data-video-id="${videoId}"]`);
          if (existingContainer) {
            existingContainer.scrollIntoView({ behavior: "smooth" });
          } else {
            appendVideoToFeed(videoId, likedVideoEl.dataset);
          }
          document.getElementById("likedVideosSection").classList.remove("show");
        }

        // Handle clicking on a search result.
        if (event.target.closest(".search-result")) {
          const resultEl = event.target.closest(".search-result");
          const videoId = resultEl.dataset.videoId;
          // If video exists in the feed, scroll to it; else append it.
          const existingContainer = document.querySelector(`.video-container[data-video-id="${videoId}"]`);
          if (existingContainer) {
            existingContainer.scrollIntoView({ behavior: "smooth" });
          } else {
            const videoData = {
              videoId: resultEl.dataset.videoId,
              title: resultEl.dataset.title,
              channelTitle: resultEl.dataset.channel,
              thumbnail: resultEl.dataset.thumbnail,
              statistics: { viewCount: resultEl.dataset.views }
            };
            appendVideoToFeedObj(videoData);
          }
          document.getElementById("searchSection").classList.remove("show");
        }
      });

      // Close comments section.
      document.getElementById("closeComments").addEventListener("click", () => {
        document.getElementById("commentsSection").classList.remove("show");
      });
      // Close liked videos section.
      document.getElementById("closeLikedVideos").addEventListener("click", () => {
        document.getElementById("likedVideosSection").classList.remove("show");
      });
      // Close search section.
      document.getElementById("closeSearch").addEventListener("click", () => {
        document.getElementById("searchSection").classList.remove("show");
      });

      // Handle posting a new comment.
      document.getElementById("submitComment").addEventListener("click", () => {
        const input = document.getElementById("commentInput");
        const text = input.value.trim();
        if (!text || !currentCommentVideoId) return;
        const commentCookie = getCookie("comments_" + currentCommentVideoId);
        let comments = [];
        if (commentCookie) {
          try {
            comments = JSON.parse(commentCookie);
          } catch (e) {
            console.error(e);
          }
        }
        comments.push({ text, timestamp: Date.now() });
        setCookie("comments_" + currentCommentVideoId, JSON.stringify(comments), 30);
        input.value = "";
        loadComments(currentCommentVideoId);
        updateCommentCount(currentCommentVideoId);
      });

      // Handle search execution.
      document.getElementById("executeSearch").addEventListener("click", async () => {
        const query = document.getElementById("searchInput").value.trim();
        if (!query) return;
        const results = await searchVideos(query, 10);
        displaySearchResults(results);
      });
    }

    // Append a video to the feed using videoData.
    function appendVideoToFeedObj(videoData) {
      const videosContainer = document.getElementById("videos");
      const uniqueId = playerIdCounter++;
      const container = createVideoContainer(videoData, uniqueId);
      videosContainer.prepend(container);
      initPlayer(uniqueId, videoData);
      if (videoObserver) {
        videoObserver.observe(container);
      }
      updateVideoRating(container, videoData);
    }

    // Append video by videoId; if data attributes are available, use them.
    async function appendVideoToFeed(videoId, dataAttrs = {}) {
      if (dataAttrs && dataAttrs.title && dataAttrs.channel) {
        const videoData = {
          videoId: dataAttrs.videoId,
          title: dataAttrs.title,
          channelTitle: dataAttrs.channel,
          thumbnail: dataAttrs.thumbnail,
          statistics: { viewCount: dataAttrs.views || "0" }
        };
        appendVideoToFeedObj(videoData);
      } else {
        const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoId}&key=${API_KEY}`;
        try {
          const res = await fetch(url);
          const data = await res.json();
          if (data.items && data.items.length) {
            const item = data.items[0];
            const videoData = {
              videoId: item.id,
              title: item.snippet.title,
              channelTitle: item.snippet.channelTitle,
              thumbnail: item.snippet.thumbnails.medium.url,
              statistics: item.statistics
            };
            appendVideoToFeedObj(videoData);
          }
        } catch (err) {
          console.error("Error appending video to feed:", err);
        }
      }
    }

    // Load liked videos into the liked videos modal.
    function loadLikedVideos() {
      const likedVideosList = document.getElementById("likedVideosList");
      likedVideosList.innerHTML = "";
      const likedVideos = getLikedVideosFromStorage();
      if (likedVideos.length === 0) {
        likedVideosList.innerHTML = "<p>No liked videos yet.</p>";
        return;
      }
      likedVideos.forEach(video => {
        const videoEl = document.createElement("div");
        videoEl.className = "liked-video";
        videoEl.dataset.videoId = video.videoId;
        videoEl.innerHTML = `
          <img src="${video.thumbnail}" alt="thumbnail" class="liked-video-thumbnail">
          <div class="liked-video-info">
            <div class="liked-video-title">${video.title}</div>
            <div class="liked-video-channel">@${video.channelTitle}</div>
          </div>
        `;
        likedVideosList.appendChild(videoEl);
      });
    }

    // Display search results in the search modal.
    function displaySearchResults(results) {
      const searchResults = document.getElementById("searchResults");
      searchResults.innerHTML = "";
      if (results.length === 0) {
        searchResults.innerHTML = "<p style='color: var(--text);'>No results found.</p>";
        return;
      }
      results.forEach(video => {
        const resultEl = document.createElement("div");
        resultEl.className = "search-result";
        resultEl.dataset.videoId = video.videoId;
        resultEl.dataset.title = video.title;
        resultEl.dataset.channel = video.channelTitle;
        resultEl.dataset.thumbnail = video.thumbnail;
        resultEl.dataset.views = video.statistics.viewCount || "0";
        resultEl.innerHTML = `
          <img src="${video.thumbnail}" alt="thumbnail" class="search-result-thumbnail">
          <div class="search-result-info">
            <div class="search-result-title">${video.title}</div>
            <div class="search-result-channel">@${video.channelTitle}</div>
          </div>
        `;
        searchResults.appendChild(resultEl);
      });
    }

    /*****************************************
     * SENTINEL OBSERVER FOR INFINITE SCROLL
     *****************************************/
    function initSentinelObserver() {
      const sentinel = document.getElementById("sentinel");
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            appendRandomVideos(5);
          }
        });
      });
      observer.observe(sentinel);
    }

    /*****************************************
     * INITIALIZATION WHEN YOUTUBE IFRAME API IS READY
     *****************************************/
    function onYouTubeIframeAPIReady() {
      appendRandomVideos(10);
      initVideoObserver();
      initSentinelObserver();
      initInteractions();
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
  </script>
</body>
</html>
